<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PV原语操作详解</title>
    <link href="/2022/05/09/PV%E5%8E%9F%E8%AF%AD%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/05/09/PV%E5%8E%9F%E8%AF%AD%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[&lt;!DOCTYPE html&gt;<html><head><title style="color:blue">PV原语操作</title></head></html><p>&lt;/!doctype&gt;</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ID3算法构建决策树</title>
    <link href="/2022/04/22/ID3%E7%AE%97%E6%B3%95%E6%9E%84%E5%BB%BA%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2022/04/22/ID3%E7%AE%97%E6%B3%95%E6%9E%84%E5%BB%BA%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="id3算法">ID3算法</h1><p><strong>ID3算法的信息论基础：</strong>机器学习算法其实很古老，代码中经常使用的if,else其实就已经在用到决策树的思想了。只是不知道读者在写代码的过程中是否会有想过用哪个条件去做if 判断，哪个去做 else判断；并且读者是否有仔细想过，这个条件判断顺序的确会影响程序运行的效率甚至准确性。所以，类比过来，在机器学习中，有这么多条件，用哪个条件特征先做if ，哪些条件特征后做 if比较会使程序更优呢？怎么准确地定量选择这个标准就是决策树机器学习算法的关键了。ID3算法是由Ross Quinlan发明的。那么在看ID3算法是怎么选择特征之前，首先我们需要知道一些信息论中的基本概念：</p><p><strong>信息：</strong>这个是熵和信息增益的基础概念，是对一个抽象事物的命名，无论用不用“信息”来命名这种抽象事物，或者用其他名称来命名这种抽象事物，这种抽象事物是客观存在的。信息论是量化处理信息的分支科学。我们可以在划分数据之前使用信息论量化度量信息的内容。集合信息的度量方式称为<strong>香农熵</strong>或者简称为<strong>熵</strong>，这个名字来源于信息论之父克劳德•香农(ClaudeElwoodShannon)。熵定义为信息的期望值，在明晰这个概念之前，我们必须知道信息的定义。如果带分类的事物集合可以划分为多个类别，则某个类<span class="math inline">\(x_i\)</span>​ 的信息（量）定义如下： <spanclass="math display">\[I(X=x_i)=-\log_2p(x_i)\]</span> 其中，<span class="math inline">\(I(X=x_i)\)</span>用来表示随机变量的信息量，<span class="math inline">\(p(x_i)\)</span> 为<span class="math inline">\(x_i\)</span> 发生时的概率。所以当事件 <spanclass="math inline">\(x_i\)</span> 发生的概率 <spanclass="math inline">\(p(x_i)\)</span>很小，但是它却发生了，那说明这个信息量相当大，比如买彩票中奖了，那么这个信息量肯定是很大的。相反，对于大概率事件，人们习以为常，那么这个事件的信息量就很小。信息量的定义是符合人们的日常认知的。</p><p><strong>信息论中的熵：</strong>熵度量了事物的不确定性，越不确定的事物，它的熵就越大。具体的，随机变量X的熵的表达式如下：<span class="math display">\[H(X)=-\sum\limits_{k=1}^np_k\log_2p_k\]</span> 其中，<span class="math inline">\(k\)</span> 代表 <spanclass="math inline">\(X\)</span> 中的 <spanclass="math inline">\(n\)</span> 种不同的离散取值，而 <spanclass="math inline">\(p_k\)</span> 代表第 <spanclass="math inline">\(k\)</span> 种离散取值的样本数占总样本数的比例</p><p><strong>推广到联合熵：</strong> <span class="math display">\[H(X,Y)=-\sum\limits_{x}\sum\limits_yp(x,y)\log_2p(x,y)\]</span></p><p><strong>继续推广到条件熵：</strong> <span class="math display">\[H(X|Y)=-\sum\limits_{x}\sum\limits_yp(x,y)\log_2p(x|y)\]</span></p><p>刚才提到 <span class="math inline">\(H(X)\)</span> 度量了 <spanclass="math inline">\(X\)</span> 的不确定性，条件熵 <spanclass="math inline">\(H(X|Y)\)</span> 度量了在知道 <spanclass="math inline">\(Y\)</span> 以后 <spanclass="math inline">\(X\)</span>剩下的不确定性。那么在这个描述下，$H(X)-H(X|Y) $代表什么呢？其实它度量了 <span class="math inline">\(X\)</span> 在知道<span class="math inline">\(Y\)</span>以后不确定性减少程度，这个度量我们在信息论中称为互信息(MutualInformation)，记为 <span class="math inline">\(I(X,Y)\)</span>。在ID3算法中叫做信息增益。ID3算法就是用信息增益来判断当前节点应该用什么特征来构建决策树。信息增益大，则越适合用来分类。原则：每次需要分裂时，计算每个属性的增益率，然后选择信息增益率最大的属性进行分裂。</p><p><strong>信息熵：</strong>度量样本纯度(不确定度)最常用的一种指标。所谓样本纯度，相反而言之就是凌乱程度。如一个数据集U中的样本都属于同一类，那么这时样本纯度最高而凌乱程度最低。如果当前样本集合D 中第 k 类样本所占的比例为 <span class="math inline">\(p_k\)</span>​，则 D 的信息熵定义为： <span class="math display">\[Ent(D)=-\sum\limits_{k=1}^np_k\log_2p_k\]</span> 其中 <span class="math inline">\(D\)</span>表示样本集合，<span class="math inline">\(k\)</span>为样本类别数目，<span class="math inline">\(p_k\)</span> 表示第 <spanclass="math inline">\(k\)</span> 种分类占集合的比例。<spanclass="math inline">\(Ent(D)\)</span> 的值越小，<spanclass="math inline">\(D\)</span>的纯度越高，因为熵度量了事物的不确定性，越不确定的事物，它的熵就越大。</p><p><strong>信息增益：</strong>使用某一个属性 <spanclass="math inline">\(a\)</span>进行划分后，所带来的纯度提高的大小（就是在划分数据集之前和之后信息发生的变化）。一般而言，信息增益越大，意味着使用属性<span class="math inline">\(a\)</span>来进行划分所获得的“纯度提升”越大。用属性 <spanclass="math inline">\(a\)</span> 对样本集 <spanclass="math inline">\(D\)</span>​ 进行划分所获得的信息增益： <spanclass="math display">\[Gain(D,a)=Ent(D)-\sum\limits_{v=1}^V\dfrac{|D^v|}{|D|}Ent(D^v)\]</span> 上述式子白话翻译就是信息增益 = 根节点的信息熵 -所有分支节点的信息熵的加权和。或者说信息增益 = 信息熵 - 条件熵。</p><p>说了这么多，下面来看一个栗子吧，这样更能对这一算法更加地了解</p><blockquote><p>[决策树]基于信息增益，对下述数据集进行决策树构建，描述过程：一个关于配眼镜的一个决策分类所需要的数据，数据集包含4属性：age,astigmatism, trear-prod-rate为输入特征，contact-lenses为决策属性。</p></blockquote><p><img src="https://raw.githubusercontent.com/zcy510/imagebed/main/img/202204221528354.png" srcset="/img/loading.gif" lazyload  /></p><ol type="1"><li><p>样本 <span class="math inline">\(D=\{1,2,3,4,\cdots,12\}\)</span>，首先计算根节点信息熵： <span class="math display">\[Ent(D)=-\sum\limits_{k=1}^{3}p_k\,\log_2p_k=-(\dfrac2{12}\log_2\dfrac2{12}+\dfrac7{12}\log_2\dfrac7{12}+\dfrac3{12}\log_2\dfrac3{12})=1.3844\]</span></p></li><li><p>计算当前属性集合<spanclass="math inline">\(\{AGE,\,ASTIGMATISM,\,TEAR-PRODUCTION-RATE\}\)</span> 中每个属性的信息增益</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">D1</span>(AGE=young)=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;, soft <span class="hljs-number">1</span>/<span class="hljs-number">3</span>, none <span class="hljs-number">1</span>/<span class="hljs-number">3</span>, hard <span class="hljs-number">1</span>/<span class="hljs-number">3</span><br><span class="hljs-attribute">D2</span>(AGE=pre-presbyopic)=&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;, soft <span class="hljs-number">1</span>/<span class="hljs-number">5</span>, none <span class="hljs-number">3</span>/<span class="hljs-number">5</span>, hard <span class="hljs-number">1</span>/<span class="hljs-number">5</span><br><span class="hljs-attribute">D3</span>(AGE=presbyopic)=&#123;<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>&#125;, soft <span class="hljs-number">0</span>, none <span class="hljs-number">3</span>/<span class="hljs-number">4</span>, hard <span class="hljs-number">1</span>/<span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure><p>这3个分支的信息熵（条件熵）： <span class="math display">\[Ent(D_1)=-(\dfrac13\log_2\dfrac13+\dfrac13\log_2\dfrac13+\dfrac13\log_2\dfrac13)=1.5850\\Ent(D_2)=-(\dfrac15\log_2\dfrac15+\dfrac35\log_2\dfrac35+\dfrac15\log_2\dfrac15)=1.3710\\Ent(D_3)=-(\dfrac34\log_2\dfrac34+\dfrac14\log_2\dfrac14)=0.8113\]</span> 那么我们可以知道 <span class="math inline">\(AGE\)</span>​属性的信息增益是： <span class="math display">\[Gain(D,\AGE)=Ent(D)-\sum\limits_{v=1}^3\dfrac{|D_v|}{|D|}Ent(D_v)=1.3844-(\dfrac3{12}\times1.5850+\dfrac5{12}\times1.3710+\dfrac4{12}\times0.8113)=0.1465\]</span> 同理，<span class="math inline">\(ASTIGMATISM\)</span> 和<span class="math inline">\(TEAR-PRODUCTION-RATE\)</span> 的信息增益为：<span class="math display">\[Gain(D,\ ASTIGMATIST)=0.4048\\Gain(D,\ TEAR-PRODUCTION-RATE)=0.3413\]</span></p></li><li><p>于是我们得到了3个属性的信息增益，我们选取当前信息增益最大的属性进行划分，得到如下决策树：</p></li></ol><pre><code class=" mermaid">graph TD1(ASTIGMATISM = ?)--no---2(&quot;&#123;1, 4, 5, 9, 10&#125;&quot;)1--yes---3(&quot;&#123;2, 3, 6, 7, 8, 11, 12&#125;&quot;)</code></pre><ol start="4" type="1"><li><p>此时决策树有2个分支，于是得到了2个子节点。对于这2个子节点，我们继续上述过程寻找信息增益最大的属性进行划分，举个栗子：<spanclass="math inline">\(D_2(ASTIGMATISM=yes)=\{2,3,6,7,8,11,12\}\)</span>，所以这个分支节点可用的属性集合为<spanclass="math inline">\(\{AGE,\ TEAR-PRODUCTION-RATE\}\)</span>。接下来的计算过程解释将该子节点看成是一个新的根节点重复上述计算过程。</p><p>首先，子节点信息熵： <span class="math display">\[Ent(D_2)=-\sum\limits_{k=1}^{2}p_k\,\log_2p_k=-(\dfrac37\log_2\dfrac37+\dfrac47\log_2\dfrac47)=0.9852\]</span> 计算当前属性集合<span class="math inline">\(\{AGE,\TEAR-PRODUCTION-RATE \}\)</span> 中每个属性的信息增益：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">D2_1</span>(TEAR-PRODUCTION-RATE=reduced)=&#123;<span class="hljs-number">2</span>, <span class="hljs-number">11</span>&#125;, soft <span class="hljs-number">0</span>, none <span class="hljs-number">1</span>, hard <span class="hljs-number">0</span><br><span class="hljs-attribute">D2_2</span>(TEAR-PRODUCTION-RATE=normal)=&#123;<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>&#125;, soft <span class="hljs-number">0</span>, none <span class="hljs-number">2</span>/<span class="hljs-number">5</span>, hard <span class="hljs-number">3</span>/<span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure><p>这2个分支的信息熵为： <span class="math display">\[Ent(D2\_1)=-(\log_21)=0\\Ent(D2\_2)=-(\dfrac25\log_2\dfrac25+\dfrac35\log_2\dfrac35)=0.9710\]</span> 那么我们可以知道这个子节点的 <spanclass="math inline">\(TEAR-PRODUCTION-RATE\)</span>​ 属性的信息增益是：<span class="math display">\[Gain(D_2,\TEAR-PRODUCTION-RATE)=0.9852-\dfrac27\times0-\dfrac57\times0.9710=0.2916\]</span> 同理，<span class="math inline">\(AGE\)</span>属性的信息增益为： <span class="math display">\[Gain(D_2,\ AGE)=0.0202\]</span> 那么比较之后可知，这个子节点应该按照属性 <spanclass="math inline">\(TEAR-PRODUCTION-RATE\)</span>进行划分；同理，子节点 <spanclass="math inline">\(\{1,4,5,9,10\}\)</span> 应该按照 <spanclass="math inline">\(AGE\)</span>属性划分，得到如下决策树(其余子节点的计算省略)：</p><pre><code class=" mermaid">graph TD1(ASTIGMATISM = ?)--no---2(&quot;&#123;1, 4, 5, 9, 10&#125;&quot;)1--yes---3(&quot;&#123;2, 3, 6, 7, 8, 11, 12&#125;&quot;)2--young---4(&quot;soft: &#123;1&#125;&quot;)2--pre-presbyotic---5(&quot;&#123;4,5&#125;&quot;)2--presbyopic---6(&quot;none: &#123;9,10&#125;&quot;)5--normal---7(&quot;none: &#123;4&#125;&quot;)5--reduced---8(&quot;soft: &#123;5&#125;&quot;)3--normal---9(&quot;&#123;3,6,7,8,12&#125;&quot;)3--reduced---10(&quot;none: &#123;2,11&#125;&quot;)9--young---11(&quot;hard: &#123;3&#125;&quot;)9--pre-presbyotic---12(&quot;&#123;6,7,8&#125;&quot;)9--presbyopic---13(&quot;hard: &#123;12&#125;&quot;)12---14(&quot;hard: &#123;6&#125;&quot;)12---15(&quot;none: &#123;7,8&#125;&quot;)</code></pre></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>决策树</tag>
      
      <tag>ID3算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构——单向链表|删除操作</title>
    <link href="/2022/04/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A82/"/>
    <url>/2022/04/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A82/</url>
    
    <content type="html"><![CDATA[<h1 id="单向链表删除">单向链表|删除</h1><p>之前已经讨论了介绍了单向链表的基础结构以及它的插入操作，现在来实现单向链表的删除操作。</p><h3 id="通过给定节点删除">通过给定节点删除</h3><p><strong>通过遍历查找实现删除操作可以总结为以下3点：</strong></p><ul><li>首先找到删除节点的前驱节点</li><li>改变前驱节点所指向的节点</li><li>将删除节点的内存释放掉</li></ul><p><imgsrc="https://raw.githubusercontent.com/zcy510/imagebed/main/img/202204202021634.png" srcset="/img/loading.gif" lazyload /></p><p><strong>注意：</strong></p><blockquote><p>因为链表的每一个节点都是动态分配的内存，因此在删除节点的时候务必记得将删除节点的内存释放掉，否则会出现内存泄露的错误</p></blockquote><p>C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//key为需要删除节点的值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(Node** head_ref, <span class="hljs-type">int</span> key)</span></span>&#123;<br>    <span class="hljs-comment">// 头节点不能丢失</span><br>    Node* temp = *head_ref;<br>    Node* prev = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">//如果删除节点为头节点，则直接改变头节点，并且释放删除节点内存</span><br>    <span class="hljs-keyword">if</span> (temp != <span class="hljs-literal">NULL</span> &amp;&amp; temp-&gt;data == key)&#123;<br>        *head_ref = temp-&gt;next; <br>        <span class="hljs-keyword">delete</span> temp;            <br>        <span class="hljs-keyword">return</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//往下遍历寻找删除节点，记录删除节点的前驱节点是因为prev-&gt;next需要指向删除节点的next</span><br>    <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">NULL</span> &amp;&amp; temp-&gt;data != key)&#123;<br>        prev = temp;<br>        temp = temp-&gt;next;<br>    &#125;<br><span class="hljs-comment">//如果没有找到</span><br>    <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 找到了，把断掉的地方链接起来</span><br>    prev-&gt;next = temp-&gt;next;<br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">delete</span> temp;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>通过递归删除指定节点</strong></p><ul><li><p>递归删除指定节点传递的参数是结点指针的引用</p></li><li><p>由于当前结点指针是从上一个节点的next(由引用传递)传递的，因此如果现在改变了当前指针的值，则前一节点的next也会改变，这正是删除节点所要做的操作</p></li></ul><p><imgsrc="https://raw.githubusercontent.com/zcy510/imagebed/main/img/202204202210916.png" srcset="/img/loading.gif" lazyload /></p><p>举个栗子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> info;<br>    node *link = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-built_in">node</span>() &#123;&#125;<br><br>    <span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> a)<br>            : <span class="hljs-built_in">info</span>(a) &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(node *&amp;head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// If current node is the node to be deleted</span><br>    <span class="hljs-keyword">if</span> (head-&gt;info == val) &#123;<br>        node *t = head;<br>        head = head-&gt;link; <span class="hljs-comment">// If it&#x27;s start of the node head node points to second node</span><br>        <span class="hljs-built_in">delete</span> (t); <span class="hljs-comment">// Else changes previous node&#x27;s link to current node&#x27;s link</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">deleteNode</span>(head-&gt;link, val);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(node *&amp;head, <span class="hljs-type">int</span> data)</span> </span>&#123;<br>    node *newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(data);<br>    newNode-&gt;link = head;<br>    head = newNode;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(node *head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>        cout &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    cout &lt;&lt; head-&gt;info &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-built_in">print</span>(head-&gt;link);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Starting with an empty linked list</span><br>    node *head = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">push</span>(head, <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">push</span>(head, <span class="hljs-number">12</span>);<br>    <span class="hljs-built_in">push</span>(head, <span class="hljs-number">14</span>);<br>    <span class="hljs-built_in">push</span>(head, <span class="hljs-number">15</span>);<br>    <span class="hljs-built_in">print</span>(head);<br><br>    <span class="hljs-built_in">deleteNode</span>(head, <span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">print</span>(head); <span class="hljs-comment">// 20 is not present thus no change in the list</span><br><br>    <span class="hljs-built_in">deleteNode</span>(head, <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">print</span>(head);<br><br>    <span class="hljs-built_in">deleteNode</span>(head, <span class="hljs-number">14</span>);<br>    <span class="hljs-built_in">print</span>(head);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">15 </span><span class="hljs-number">14</span> <span class="hljs-number">12</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">15 </span><span class="hljs-number">14</span> <span class="hljs-number">12</span> <span class="hljs-number">10</span> <br><span class="hljs-symbol">15 </span><span class="hljs-number">14</span> <span class="hljs-number">12</span> <br><span class="hljs-symbol">15 </span><span class="hljs-number">12</span> <br></code></pre></div></td></tr></table></figure><h3 id="通过给定位置删除">通过给定位置删除</h3><p>给定单向链表和一个位置，删除给定位置的链表节点</p><p><strong>Example:</strong></p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Input</span>: position = <span class="hljs-number">1</span>, Linked List = <span class="hljs-number">8</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">7</span><br><span class="hljs-attribute">Output</span>: Linked List =  <span class="hljs-number">8</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">7</span><br><br><span class="hljs-attribute">Input</span>: position = <span class="hljs-number">0</span>, Linked List = <span class="hljs-number">8</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">7</span><br><span class="hljs-attribute">Output</span>: Linked List = <span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">7</span><br></code></pre></div></td></tr></table></figure><p>以下是C++实现栗子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> data;<br>    Node *next;<br>&#125;;<br><br><span class="hljs-comment">//头插法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Node **head_ref, <span class="hljs-type">int</span> new_data)</span> </span>&#123;<br>    Node *new_node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>    new_node-&gt;data = new_data;<br>    new_node-&gt;next = (*head_ref);<br>    (*head_ref) = new_node;<br>&#125;<br><br><span class="hljs-comment">//给定指向头节点的指针和位置（下标）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(Node **head_ref, <span class="hljs-type">int</span> position)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (*head_ref == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 头指针不能改变，以防丢失链表</span><br>    Node *temp = *head_ref;<br>    <span class="hljs-comment">// 特殊位置0</span><br>    <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//改变头指针</span><br>        *head_ref = temp-&gt;next;<br>        <span class="hljs-built_in">free</span>(temp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果删除节点为中间节点，循环结束后，temp为删除节点的前驱节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; temp != <span class="hljs-literal">NULL</span> &amp;&amp; i &lt; position - <span class="hljs-number">1</span>; i++)<br>        temp = temp-&gt;next;<br><br>    <span class="hljs-comment">// 如果给定位置大于链表长度，则直接退出</span><br>    <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span> || temp-&gt;next == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//next为删除节点的后驱节点</span><br>    Node *next = temp-&gt;next-&gt;next;<br>    <span class="hljs-comment">//断链,释放内存</span><br>    <span class="hljs-built_in">free</span>(temp-&gt;next); <span class="hljs-comment">// Free memory</span><br>    <span class="hljs-comment">//重新链接</span><br>    temp-&gt;next = next;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(Node *node)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>        cout &lt;&lt; node-&gt;data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        node = node-&gt;next;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Node *head = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">push</span>(&amp;head, <span class="hljs-number">7</span>);<br>    <span class="hljs-built_in">push</span>(&amp;head, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">push</span>(&amp;head, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">push</span>(&amp;head, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">push</span>(&amp;head, <span class="hljs-number">8</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Created Linked List: &quot;</span>;<br>    <span class="hljs-built_in">printList</span>(head);<br>    <span class="hljs-built_in">deleteNode</span>(&amp;head, <span class="hljs-number">4</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;\nLinked List after Deletion at position 4: &quot;</span>;<br>    <span class="hljs-built_in">printList</span>(head);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Created</span> Linked List: <span class="hljs-number">8</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span><br><span class="hljs-attribute">Linked</span> List after Deletion at position <span class="hljs-number">4</span>: <span class="hljs-number">8</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><h3 id="删除整个链表">删除整个链表</h3><p>因为C++没有自动回收内存的机制，所以如果想要删除整个链表，只执行head=NULL 是不够的，以下为C++实现样例：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteList</span><span class="hljs-params">(Node **head_ref)</span> </span>&#123;<br>    Node *current = *head_ref;<br>    Node *next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">NULL</span>) &#123;<br>        next = current-&gt;next;<br>        <span class="hljs-built_in">free</span>(current);<br>        current = next;<br>    &#125;<br>    *head_ref = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构——单向链表|插入操作</title>
    <link href="/2022/04/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A81/"/>
    <url>/2022/04/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A81/</url>
    
    <content type="html"><![CDATA[<h1 id="单向链表插入">单向链表|插入</h1><p><strong>在链表头部插入新节点</strong></p><p><imgsrc="https://raw.githubusercontent.com/zcy510/imagebed/main/img/202204201848560.png" srcset="/img/loading.gif" lazyload /></p><p>C++实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//参数为一个指向头指针的指针，和一个新节点的数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Node** head_ref, <span class="hljs-type">int</span> new_data)</span></span>&#123;<br><span class="hljs-comment">//创建新节点</span><br>Node* new_node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>new_node-&gt;data = new_data;<br><span class="hljs-comment">//新节点应该指向头节点（之前的）</span><br>new_node-&gt;next = (*head_ref);<br><span class="hljs-comment">//新的头节点应该是刚插入的新节点</span><br>(*head_ref) = new_node;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>在指定节点后面插入新节点</strong></p><p><imgsrc="https://raw.githubusercontent.com/zcy510/imagebed/main/img/202204201853068.png" srcset="/img/loading.gif" lazyload /></p><p>C++实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//参数为给定插入位置节点，和新节点数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAfter</span><span class="hljs-params">(Node* prev_node, <span class="hljs-type">int</span> new_data)</span></span>&#123;<br><br><span class="hljs-comment">// 检查位置节点是否为NULL，如果是的话，就返回，说明参数传错了；前驱节点不能为NULL</span><br><span class="hljs-keyword">if</span> (prev_node == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//创建新的节点</span><br>Node* new_node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>new_node-&gt;data = new_data;<br><span class="hljs-comment">// 新节点的应该指向prev_node的下一个节点</span><br>new_node-&gt;next = prev_node-&gt;next;<br><span class="hljs-comment">//prev_node应该指向新节点</span><br>prev_node-&gt;next = new_node;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>在链表尾部插入新节点</strong></p><p><imgsrc="https://raw.githubusercontent.com/zcy510/imagebed/main/img/202204201900598.png" srcset="/img/loading.gif" lazyload /></p><p>C++实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//参数为一个指向头指针的指针，和一个新节点的数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(Node** head_ref, <span class="hljs-type">int</span> new_data)</span></span>&#123;<br><span class="hljs-comment">// 创建新节点</span><br>Node* new_node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>new_node-&gt;data = new_data;<br><span class="hljs-comment">// 新节点应该指向NULL</span><br>new_node-&gt;next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">// 判断链表是否为空，如果是，则直接头节点指向新节点，然后返回即可</span><br><span class="hljs-keyword">if</span> (*head_ref == <span class="hljs-literal">NULL</span>)&#123;<br>*head_ref = new_node;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//从头节点开始遍历，寻找尾节点</span><br>Node *last = *head_ref;<br><span class="hljs-keyword">while</span> (last-&gt;next != <span class="hljs-literal">NULL</span>)&#123;<br>last = last-&gt;next;<br>&#125;<br><span class="hljs-comment">// 将尾节点指向新节点</span><br>last-&gt;next = new_node;<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构——单向链表|引入</title>
    <link href="/2022/04/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/04/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="单向链表引入">单向链表|引入</h1><p>与数组一样，链表是一种线性数据结构。但与数组不同，链表元素没有储存在连续的内存中，而是使用指针链接存储在离散的内存空间中。</p><p><imgsrc="https://raw.githubusercontent.com/zcy510/imagebed/main/img/202204201044850.png" srcset="/img/loading.gif" lazyload /></p><p><strong>为什么选择链表结构？</strong></p><p>数组虽然可以用于存储线性的数据，但它有以下缺点：</p><ul><li>数组的大小是固定的，因此我们必须提前了解元素数量的上限。此外通常，当使用数组时，分配的空间需等于上限，这不可避免的可能产生了内存浪费。</li><li>在数组的指定位置插入一个新元素其代价是昂贵的，因为必须给新元素腾出一个空间，并且新元素后的所有元素必须相应都往后移动一个位置；同样的，删除一个元素的代价同样昂贵，删除元素后面的所有元素都需往前移动一个位置。</li></ul><p><strong>链表相较于数组的优点</strong></p><ul><li>动态大小，不需要提前设定链表长度</li><li>插入删除操作简单</li></ul><p><strong>缺点</strong></p><ul><li>不允许随机访问（通过元素下标）。链表元素离散存储的属性决定了链表元素的访问只能从头节点顺序进行访问</li><li>链表的每个元素需要指向下一元素指针的额外内存空间</li></ul><p><strong>链表的表示形式</strong></p><p>链表由一个指向链表的第一个节点的指针表示。第一个节点称为头节点。如果链表为空，则头节点指向NULL。</p><p>链表中的每一个节点至少由两部分组成：</p><ol type="1"><li>数据</li><li>指向下一节点的指针（或引用）</li></ol><p>以下是C++的链表节点表示</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// A linked list node</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> data;<br>    Node* next;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><p><strong>一个简单链表的例子</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// A simple CPP program to introduce</span><br><span class="hljs-comment">// a linked list</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> data;<br>Node* next;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>Node* head = <span class="hljs-literal">NULL</span>;<br>Node* second = <span class="hljs-literal">NULL</span>;<br>Node* third = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// allocate 3 nodes in the heap</span><br>head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>second = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>third = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br><br>head-&gt;data = <span class="hljs-number">1</span>; <br>head-&gt;next = second; <br><br>second-&gt;data = <span class="hljs-number">2</span>;<br>second-&gt;next = third;<br><br>third-&gt;data = <span class="hljs-number">3</span>; <br>third-&gt;next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><pre><code class=" mermaid">graph LR0((head))--&gt;1--&gt;2--&gt;3--&gt;NULL</code></pre><p><strong>链表的遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// A simple C++ program for traversal of a linked list</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> data;<br>Node* next;<br>&#125;;<br><br><span class="hljs-comment">// This function prints contents of linked list</span><br><span class="hljs-comment">// starting from the given node</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(Node* n)</span></span>&#123;<br><span class="hljs-keyword">while</span> (n != <span class="hljs-literal">NULL</span>) &#123;<br>cout &lt;&lt; n-&gt;data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>n = n-&gt;next;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Node* head = <span class="hljs-literal">NULL</span>;<br>Node* second = <span class="hljs-literal">NULL</span>;<br>Node* third = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// allocate 3 nodes in the heap</span><br>head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>second = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>third = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br><br>head-&gt;data = <span class="hljs-number">1</span>; <br>head-&gt;next = second; <br><br>second-&gt;data = <span class="hljs-number">2</span>; <br>second-&gt;next = third;<br><br>third-&gt;data = <span class="hljs-number">3</span>; <br>third-&gt;next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-built_in">printList</span>(head);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></div></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span> <span class="hljs-number">2</span>  <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学期末项目——C++实现一个简单的光追模型</title>
    <link href="/2022/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%9C%9F%E6%9C%AB%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94C-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%85%89%E8%BF%BD%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%9C%9F%E6%9C%AB%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94C-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%85%89%E8%BF%BD%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机图形学期末报告">《计算机图形学》期末报告</h1><h3 id="简单物体的光线追踪模型">简单物体的光线追踪模型</h3><p>​ 学校：华东师范大学</p><p>​ 院系：计算机科学与技术学院</p><p>​ 专业：计算机图形学</p><p>​ 年级：2020级</p><p>​ 作者： zcy</p><p>​ 学号：***********</p><p>​ 日期：2021.12.25</p><p><img src="https://raw.githubusercontent.com/zcy510/imagebed/main/img/202204181616102.png" srcset="/img/loading.gif" lazyload alt="ecnu_logo" style="zoom:33%;" /></p><p>[TOC]</p><h5 id="第一章.-报告简介">第一章. 报告简介</h5><p>本项目通过光线追踪算法实现一些简单物体的渲染，并通过文件输出流方式将渲染的图片写入PPM格式中。通俗来讲就是追踪“目所能及”的光线路径，所以容易被误解成是从“照相机”（观察者位置）发出光线，但是这种方法能够更加准确现实地模拟光线，实现很好的图像效果；反射、折射、阴影都是这个算法的一个自然结果。</p><h5 id="第二章.-项目结构目录">第二章. 项目结构目录</h5><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">Eigen                     //矩阵类头文件<br>camera.h                  //摄像机（观察者）类<br>color.h                   //颜色类<br>ellipsoid.h               //椭球类<br>hittable.h                //碰撞类<br>hittable<span class="hljs-built_in">_</span>list.h           //多物体碰撞类<br>material.h                //材料类<br>ray.h                     //光线类<br>rtweekend.h               //常用的函数和常用的常量在此定义<br>sphere.h                  //球类<br>vec3.h                    //三维坐标类<br>main.cpp                  //主函数，将每个像素颜色的RGB值写入PPM文件<br>    <br></code></pre></div></td></tr></table></figure><h5 id="第三章.-建模核心技术">第三章. 建模核心技术</h5><h6 id="光线追踪算法">1. 光线追踪算法</h6><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">光线追踪 (Ray Tracing) 算法是一种基于真实光路模拟的计算机三维图形渲染算法，相比其它大部分渲染算法，光线追踪算法可以提供更为真实的光影效果。此算法由 Appel 在 1968 年初步提出，1980 年由Whitted 改良为递归算法并提出全局光照模型。直到今天，光线追踪算法仍是图形学的热点，大量的改进在不断涌现。基于对自然界光路的研究, 光线追踪采取逆向计算光路来还原真实颜色。追踪的过程中涵盖了光的反射、折射、吸收等特性 (精确计算)， 并辅以其它重要渲染思想 (进一步模拟)。 其中包含了重要方法，诸如冯氏光照模型 (Phong Shading)、辐射度(Radiosity)、光子映射 (Photon Mapping)、蒙特卡罗方法 (Monte Carlo) 等等。<br></code></pre></div></td></tr></table></figure><h6 id="圆球求交算法">2. 圆球求交算法</h6><p>在 <span class="math inline">\(ray.h\)</span>头文件内，将光线定义成了如下形式： <span class="math display">\[P(t)=orgin+t*direction\]</span> 其中， <span class="math inline">\(orgin\)</span>为光线发出点，<span class="math inline">\(direction\)</span>为光线的方向向量，此种定义方式在稍后的椭球求交中也方便计算。</p><p>我们记球的球心为 <spanclass="math inline">\(C\,(C_x,C_y,C_z)\)</span>，球的半径为 <spanclass="math inline">\(R\)</span> ，则球的方程为： <spanclass="math display">\[(x-C_x)^2+(y-C_y)^2+(z-C_z)^2 = R^2\]</span> 方程可以替换成向量方程， <span class="math display">\[(P(t)-C)(P(t)-C)=R^2\\\Rightarrow (orgin+t*direction-C)^2=R^2\]</span> 展开可以得到一个一元二次方程， <span class="math display">\[(direction)^2\cdot t^2+2\cdot direction\cdot (origin-C)\cdot t+(origin-C)^2-R^2=0\]</span>至此，求解光线与球的交点问题就变成了一个一元二次方程的求解问题，运算不多赘述，代码如下，</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sphere::hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray &amp;r, <span class="hljs-type">double</span> t_min, <span class="hljs-type">double</span> t_max, hit_record &amp;rec)</span> <span class="hljs-type">const</span> </span>&#123;<br>    vec3 oc = r.<span class="hljs-built_in">origin</span>() - center;<br>    <span class="hljs-keyword">auto</span> a = r.<span class="hljs-built_in">direction</span>().<span class="hljs-built_in">length_squared</span>();<br>    <span class="hljs-keyword">auto</span> half_b = <span class="hljs-built_in">dot</span>(oc, r.<span class="hljs-built_in">direction</span>());<br>    <span class="hljs-keyword">auto</span> c = oc.<span class="hljs-built_in">length_squared</span>() - radius * radius;<br><br>    <span class="hljs-keyword">auto</span> discriminant = half_b * half_b - a * c;<br>    <span class="hljs-keyword">if</span> (discriminant &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">auto</span> sqrtd = <span class="hljs-built_in">sqrt</span>(discriminant);<br><br>    <span class="hljs-comment">// Find the nearest root that lies in the acceptable range.</span><br>    <span class="hljs-keyword">auto</span> root = (-half_b - sqrtd) / a;<br>    <span class="hljs-keyword">if</span> (root &lt; t_min || t_max &lt; root) &#123;<br>        root = (-half_b + sqrtd) / a;<br>        <span class="hljs-keyword">if</span> (root &lt; t_min || t_max &lt; root)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    rec.t = root;<br>    rec.p = r.<span class="hljs-built_in">at</span>(rec.t);<br>    vec3 outward_normal = (rec.p - center) / radius;<br>    rec.<span class="hljs-built_in">set_face_normal</span>(r, outward_normal);<br>    rec.mat_ptr = mat_ptr;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h6 id="椭球求交算法">3. 椭球求交算法</h6><p><img src="https://raw.githubusercontent.com/zcy510/imagebed/main/img/202204181616597.png" srcset="/img/loading.gif" lazyload alt="image-20211226104611544"  /></p><p>上述示意图中，<span class="math inline">\(C\)</span>为椭球球心，<span class="math inline">\(a\)</span> 为 <spanclass="math inline">\(x\)</span> 轴向半径，<spanclass="math inline">\(b\)</span> 为 <spanclass="math inline">\(y\)</span> 轴向半径，<spanclass="math inline">\(c\)</span> 为 <spanclass="math inline">\(z\)</span> 轴向半径，<spanclass="math inline">\(L_0\)</span> 为光线起点，<spanclass="math inline">\(v\)</span> 为光线方向矢量。</p><p>如下矩阵是将椭球转化成球心位于原点处的单位球的变换矩阵。 <spanclass="math display">\[T = \left[\matrix{  1 &amp; 0 &amp; 0　&amp; C_x\\  0 &amp; 1 &amp; 0 &amp; C_y\\  0 &amp; 0 &amp; 1 &amp; C_z\\  0 &amp; 0 &amp; 0 &amp; 1}\right],\quadR=\left[\matrix{  \hat{a_x} &amp; \hat{b_x} &amp; \hat{c_x}　&amp; 0\\  \hat{a_y} &amp; \hat{b_y} &amp; \hat{c_z} &amp; 0\\  \hat{a_z} &amp; \hat{b_z} &amp; \hat{c_z} &amp; 0\\  0 &amp; 0 &amp; 0 &amp; 1}\right],\quadS= \left[\matrix{  ||a|| &amp; 0 &amp; 0　&amp; 0\\  0 &amp; ||b|| &amp; 0 &amp; 0\\  0 &amp; 0 &amp; ||c|| &amp; 0\\  0 &amp; 0 &amp; 0 &amp; 1}\right]\]</span> 其中 <span class="math inline">\(T\)</span> 为平移矩阵，<spanclass="math inline">\(R\)</span> 为旋转矩阵，<spanclass="math inline">\(S\)</span> 为缩放矩阵。那么组合变换矩阵 <spanclass="math inline">\(M=TRS\)</span>。</p><p>思路为：</p><ol type="1"><li>将该变换应用于与椭球体进行相交计算的直线。</li><li>计算变换后的直线与与位于原点的单位球体的相交情况。</li><li>将结果应用于变换前的直线，获取相交点。</li></ol><p>若以 <span class="math inline">\(C&#39;\)</span>为单位球体的球心，则球体表面上的点应该满足： <spanclass="math display">\[||P-C&#39;||^2=(R&#39;)^2\]</span> 由于球体为球心位于原点的单位球体，因此 <spanclass="math inline">\(C&#39;\)</span> 为原点，且 <spanclass="math inline">\(R&#39;\)</span> 为1： <spanclass="math display">\[C&#39;=M^{-1}C=\left[\matrix{0\\0\\0\\1}\right]\, R&#39;=1\]</span> 同样，在求椭球的交点的过程中，直线使用参数方程的表示： <spanclass="math display">\[L(t)=L_0+t*v\]</span> 对直线进行坐标转换（和转换矩阵相乘）： <spanclass="math display">\[L&#39;(t)=M^{-1}L_0+M^{-1}*t*v\]</span> 记 <span class="math inline">\(L&#39;_0=M^{-1}L_0,\, v&#39; =M^{-1}v\)</span>，接下来的运算就和上面所述的圆球求交算法一样了，此处不多赘述，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//矩阵求逆，求转换后的L0和v</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inverseMatrix</span><span class="hljs-params">(vec3 cen, vec3 &amp;origin, vec3 &amp;direction, <span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">double</span> z)</span> </span>&#123;<br>    Matrix4d m1, m2, m3, m4, m5;<br>    m1 &lt;&lt; <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, cen.<span class="hljs-built_in">x</span>(),<br>            <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cen.<span class="hljs-built_in">y</span>(),<br>            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, cen.<span class="hljs-built_in">z</span>(),<br>            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//std::cout&lt;&lt;m1.inverse();</span><br>    m5 &lt;&lt; <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>            <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<br>            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>;<br>    m2 &lt;&lt; x, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>            <span class="hljs-number">0</span>, y, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, z, <span class="hljs-number">1</span>,<br>            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>;<br><br>    m3 = m1 * m5*m2;<br>    m4 = m3.<span class="hljs-built_in">inverse</span>();<br>    <span class="hljs-function">Vector4d <span class="hljs-title">v1</span><span class="hljs-params">(origin.x(), origin.y(), origin.z(), <span class="hljs-number">1</span>)</span>, <span class="hljs-title">v2</span><span class="hljs-params">(direction.x(), direction.y(), direction.z(), <span class="hljs-number">1</span>)</span></span>;<br>    v1 = m4 * v1;<br>    v2 = m4 * v2;<br>    origin[<span class="hljs-number">0</span>] = <span class="hljs-built_in">v1</span>(<span class="hljs-number">0</span>), origin[<span class="hljs-number">1</span>] = <span class="hljs-built_in">v1</span>(<span class="hljs-number">1</span>), origin[<span class="hljs-number">2</span>] = <span class="hljs-built_in">v1</span>(<span class="hljs-number">2</span>);<br>    direction[<span class="hljs-number">0</span>] = <span class="hljs-built_in">v2</span>(<span class="hljs-number">0</span>), direction[<span class="hljs-number">1</span>] = <span class="hljs-built_in">v2</span>(<span class="hljs-number">1</span>), direction[<span class="hljs-number">2</span>] = <span class="hljs-built_in">v2</span>(<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ellipsoid::hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray &amp;r, <span class="hljs-type">double</span> t_min, <span class="hljs-type">double</span> t_max, hit_record &amp;rec)</span> <span class="hljs-type">const</span> </span>&#123;<br><br>    vec3 tmp1,tmp2;<br>    tmp1=r.<span class="hljs-built_in">origin</span>(),tmp2=r.<span class="hljs-built_in">direction</span>();<br>    <span class="hljs-built_in">inverseMatrix</span>(center,tmp1,tmp2,a,b,c);<br><br>    <span class="hljs-keyword">auto</span> a = tmp2.<span class="hljs-built_in">length_squared</span>();<br>    <span class="hljs-keyword">auto</span> half_b = <span class="hljs-built_in">dot</span>(tmp1,tmp2);<br>    <span class="hljs-keyword">auto</span> c = tmp1.<span class="hljs-built_in">length_squared</span>()<span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">auto</span> discriminant = half_b*half_b-a*c;<br>    <span class="hljs-keyword">if</span> (discriminant &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">auto</span> sqrtd = <span class="hljs-built_in">sqrt</span>(discriminant);<br><br>    <span class="hljs-comment">// Find the nearest root that lies in the acceptable range.</span><br>    <span class="hljs-keyword">auto</span> root = (-half_b - sqrtd) / a;<br>    <span class="hljs-keyword">if</span> (root &lt; t_min || t_max &lt; root) &#123;<br>        root = (-half_b + sqrtd) / a;<br>        <span class="hljs-keyword">if</span> (root &lt; t_min || t_max &lt; root)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    rec.t = root;<br>    rec.p = r.<span class="hljs-built_in">at</span>(rec.t);<br>    <span class="hljs-function">vec3 <span class="hljs-title">elli_normal</span><span class="hljs-params">(<span class="hljs-number">2</span>*rec.p.x()/(a*a),<span class="hljs-number">2</span>*rec.p.y()/(b*b),<span class="hljs-number">2</span>*rec.p.z()/(c*c))</span></span>;<br>    vec3 outward_normal = <span class="hljs-built_in">unit_vector</span>(elli_normal);<br>    rec.<span class="hljs-built_in">set_face_normal</span>(r, outward_normal);<br>    rec.mat_ptr = mat_ptr;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h6 id="光线追踪递归算法">4. 光线追踪递归算法</h6><p>此函数首先判断光线是否与场景中的物体相交，若光线与物体相交，同时这个交点比之前的交点还要接近摄像机，则记录这一交点，抛弃之前的交点。函数执行完后，要么返回没有交点的信息，要么返回交点的位置、法线和材质。如果返回的是没有交点的情况，则递归函数也需要退出，此时返回一个特定的颜色结果，一般为背景颜色信息。如果返回的是有交点的情况，就需要根据交点处的材质情况，生成新的光线以及这个光线的颜色衰减参数。对于漫反射材质，它在不同的球面角度上是均匀分布的，对于镜面反射材质，它在球面上呈特定的分布。光线确定后，在此处继续调用这个递归函数，获得这根光线与场景中的全部物体相交后所得到的颜色。对这个颜色按刚才计算相交点材质所得到的衰减系数进行计算，就得到这一像素点最终的颜色。对于某些材质而言，可能本身就按一定概率不生成新的光线（全部吸收掉了），此时递归退出，并返回默认颜色（黑色）。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">color <span class="hljs-title">ray_color</span><span class="hljs-params">(<span class="hljs-type">const</span> ray &amp;r, <span class="hljs-type">const</span> hittable &amp;world, <span class="hljs-type">int</span> depth)</span> </span>&#123;<br>    hit_record rec;<br><br>    <span class="hljs-comment">// If we&#x27;ve exceeded the ray bounce limit, no more light is gathered.</span><br>    <span class="hljs-keyword">if</span> (depth &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">color</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span> (world.<span class="hljs-built_in">hit</span>(r, <span class="hljs-number">0.001</span>, infinity, rec)) &#123;<br>        ray scattered;<br>        color attenuation;<br>        <span class="hljs-keyword">if</span> (rec.mat_ptr-&gt;<span class="hljs-built_in">scatter</span>(r, rec, attenuation, scattered))<br>            <span class="hljs-keyword">return</span> attenuation * <span class="hljs-built_in">ray_color</span>(scattered, world, depth - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">color</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    vec3 unit_direction = <span class="hljs-built_in">unit_vector</span>(r.<span class="hljs-built_in">direction</span>());<br>    <span class="hljs-keyword">auto</span> t = <span class="hljs-number">0.5</span> * (unit_direction.<span class="hljs-built_in">y</span>() + <span class="hljs-number">1.0</span>);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">1.0</span> - t) * <span class="hljs-built_in">color</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>) + t * <span class="hljs-built_in">color</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h6 id="lambertian-reflection-反射实现朗伯辐射体磨砂材质">5. <spanclass="math inline">\(Lambertian\)</span> <spanclass="math inline">\(Reflection\)</span>反射实现朗伯辐射体（磨砂材质）</h6><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">余弦辐射体，也称为朗伯辐射体(Lambert radiator)，指的是发光强度的空间分布符合余弦定律的发光体（不论是自发光或是反射光），其在不同角度的辐射强度会依余弦公式变化，角度越大强度越弱。<br></code></pre></div></td></tr></table></figure><p><span class="math display">\[L_{\theta}=\dfrac{I_{\theta}}{dA\cos\theta}=\dfrac{I_{N}\cos\theta}{dA\cos\theta}\]</span></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">遵循朗伯定律的表面被称为兰伯特表面，并表现出朗伯反射率。这样的表面从任何角度看都具有相同的辐射度。这意味着，例如，对人眼而言，它具有相同的视亮度（或亮度）。因为功率和实心角之间的比例是恒定的，所以辐射度（单位实心角单位投射源面积的功率）保持不变。<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> vec3 <span class="hljs-title">random_in_unit_sphere</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">auto</span> p = vec3::<span class="hljs-built_in">random</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (p.<span class="hljs-built_in">length_squared</span>() &gt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">vec3 <span class="hljs-title">random_unit_vector</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">unit_vector</span>(<span class="hljs-built_in">random_in_unit_sphere</span>());<br>&#125;<br></code></pre></div></td></tr></table></figure><p><span class="math inline">\(Lambertian\)</span> 材料类的实现：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">lambertian</span> : <span class="hljs-keyword">public</span> material &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">lambertian</span>(<span class="hljs-type">const</span> color &amp;a) : <span class="hljs-built_in">albedo</span>(a) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">scatter</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">const</span> ray &amp;r_in, <span class="hljs-type">const</span> hit_record &amp;rec, color &amp;attenuation, ray &amp;scattered</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> scatter_direction = rec.normal + <span class="hljs-built_in">random_unit_vector</span>();    <span class="hljs-comment">//获取随机的散射光线</span><br><br>        <span class="hljs-comment">// Catch degenerate scatter direction</span><br>        <span class="hljs-keyword">if</span> (scatter_direction.<span class="hljs-built_in">near_zero</span>())<br>            scatter_direction = rec.normal;<br><br>        scattered = <span class="hljs-built_in">ray</span>(rec.p, scatter_direction);<br>        attenuation = albedo;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    color albedo;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h6 id="金属类材质">6. 金属类材质</h6><p>金属类材质就是只有反射没有折射的一种材料，但同时不同金属之间的反射特点也不一样。比如抛光的不锈钢材料，这种我们可以看成是全反射的材料，还有一些表面不是那么光滑的金属，那么他也会存在有漫反射，所以我们对金属类材质除了添加颜色参数以外，我们还添加一个参数<span class="math inline">\(fuzz\)</span>，用于模拟金属的漫反射（金属的模糊度，实现方法见下述代码中含有注释的一行）。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">metal</span> : <span class="hljs-keyword">public</span> material &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">metal</span>(<span class="hljs-type">const</span> color &amp;a, <span class="hljs-type">double</span> f) : <span class="hljs-built_in">albedo</span>(a), <span class="hljs-built_in">fuzz</span>(f &lt; <span class="hljs-number">1</span> ? f : <span class="hljs-number">1</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">scatter</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">const</span> ray &amp;r_in, <span class="hljs-type">const</span> hit_record &amp;rec, color &amp;attenuation, ray &amp;scattered</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        vec3 reflected = <span class="hljs-built_in">reflect</span>(<span class="hljs-built_in">unit_vector</span>(r_in.<span class="hljs-built_in">direction</span>()), rec.normal);<br>        scattered = <span class="hljs-built_in">ray</span>(rec.p, reflected + fuzz * <span class="hljs-built_in">random_in_unit_sphere</span>());  <span class="hljs-comment">//获取反射光线</span><br>        attenuation = albedo;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">dot</span>(scattered.<span class="hljs-built_in">direction</span>(), rec.normal) &gt; <span class="hljs-number">0</span>);<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    color albedo;<br>    <span class="hljs-type">double</span> fuzz;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h6 id="玻璃类材质无色">7. 玻璃类材质（无色）</h6><p>玻璃类材质可以透光，所以存在折射现象，并且不同玻璃的折射率不同，所以在<span class="math inline">\(dielectric\)</span> 类中，我们添加了一个参数<span class="math inline">\(ir\)</span>用于表示该材质的折射率；但有这个还不够，因为光的折射同样应该满足能量守恒定律，即入射光能量=反射光能量+折射光能量。所以我们还应该添加一个反射率，但真实的玻璃具有随角度变化的反射率（比如以陡峭的角度看窗户，它将变成一面镜子），此处我们使用<span class="math inline">\(Christophe\)</span> <spanclass="math inline">\(Schlick\)</span> 多项式去近似。 <spanclass="math display">\[R(\theta)=R_0+(1-R_0)(1-\cos\theta)^5\\R_0=(\dfrac{n_1-n_2}{n_1+n_2})^2\]</span> 这里的 <span class="math inline">\(\theta\)</span>是入射光线与交点处法线的夹角，<span class="math inline">\(n_1\)</span>和 <span class="math inline">\(n_2\)</span>分别是光传播介质的折射率（本项目中都是真空，即 <spanclass="math inline">\(n_1=1\)</span>） 和光击中物体的折射率。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">dielectric</span> : <span class="hljs-keyword">public</span> material &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">dielectric</span>(<span class="hljs-type">double</span> index_of_refraction) : <span class="hljs-built_in">ir</span>(index_of_refraction) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">scatter</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">const</span> ray &amp;r_in, <span class="hljs-type">const</span> hit_record &amp;rec, color &amp;attenuation, ray &amp;scattered</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        attenuation = <span class="hljs-built_in">color</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br>        <span class="hljs-type">double</span> refraction_ratio = rec.front_face ? (<span class="hljs-number">1.0</span> / ir) : ir;<br><br>        vec3 unit_direction = <span class="hljs-built_in">unit_vector</span>(r_in.<span class="hljs-built_in">direction</span>());<br><br>        <span class="hljs-type">double</span> cos_theta = <span class="hljs-built_in">fmin</span>(<span class="hljs-built_in">dot</span>(-unit_direction, rec.normal), <span class="hljs-number">1.0</span>);<br>        <span class="hljs-type">double</span> sin_theta = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> - cos_theta * cos_theta);<br><br>        <span class="hljs-type">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="hljs-number">1.0</span>;<br>        vec3 direction;<br><br>        <span class="hljs-keyword">if</span> (cannot_refract || <span class="hljs-built_in">reflectance</span>(cos_theta, refraction_ratio) &gt; <span class="hljs-built_in">random_double</span>())<br>            direction = <span class="hljs-built_in">reflect</span>(unit_direction, rec.normal);<br>        <span class="hljs-keyword">else</span><br>            direction = <span class="hljs-built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);<br><br>        scattered = <span class="hljs-built_in">ray</span>(rec.p, direction);<br>        vec3 refracted = <span class="hljs-built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);<br><br>        scattered = <span class="hljs-built_in">ray</span>(rec.p, refracted);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">double</span> ir; <span class="hljs-comment">// Index of Refraction</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title">reflectance</span><span class="hljs-params">(<span class="hljs-type">double</span> cosine, <span class="hljs-type">double</span> ref_idx)</span> </span>&#123;<br>        <span class="hljs-comment">// Use Schlick&#x27;s approximation for reflectance.</span><br>        <span class="hljs-keyword">auto</span> r0 = (<span class="hljs-number">1</span> - ref_idx) / (<span class="hljs-number">1</span> + ref_idx);<br>        r0 = r0 * r0;<br>        <span class="hljs-keyword">return</span> r0 + (<span class="hljs-number">1</span> - r0) * <span class="hljs-built_in">pow</span>((<span class="hljs-number">1</span> - cosine), <span class="hljs-number">5</span>);<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><h6 id="折射函数的实现">8. 折射函数的实现</h6><p><img src="https://raw.githubusercontent.com/zcy510/imagebed/main/img/202204181617837.png" srcset="/img/loading.gif" lazyload alt="image-20211226200613657" style="zoom: 25%;" /></p><p>根据斯涅尔定律： <span class="math display">\[n_1\cdot \sin\theta_1 = n_2\cdot \sin\theta_2\\\Rightarrow \sin\theta_2=\dfrac{n_1}{n_2}\cdot \sin\theta_1\]</span> 折射光线为 <span class="math inline">\(Q\)</span>，则其可以分解成： <span class="math display">\[Q=Q_{\perp}+Q_{\parallel}\]</span> 不难计算得： <span class="math display">\[Q_{\perp}=\dfrac{n_1}{n_2}(Q+\cos\theta_2\cdot n)\\Q_{\parallel}=-\sqrt{1-|Q_{\perp}|^2}\cdot n\\\]</span> 替换 <span class="math inline">\(\cos\theta_2\)</span> ：<span class="math display">\[Q_{\perp}=\dfrac{n_1}{n_2}\cdot (Q+(-Q\cdot n)\cdot n)\]</span> 其中 <span class="math inline">\(n\)</span>为法向量。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">vec3 <span class="hljs-title">refract</span><span class="hljs-params">(<span class="hljs-type">const</span> vec3&amp; uv, <span class="hljs-type">const</span> vec3&amp; n, <span class="hljs-type">double</span> etai_over_etat)</span> </span>&#123;<br><span class="hljs-keyword">auto</span> cos_theta = <span class="hljs-built_in">dot</span>(-uv, n);<br>vec3 r_out_perp = etai_over_etat * (uv + cos_theta * n);<br>vec3 r_out_parallel = -<span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">fabs</span>(<span class="hljs-number">1.0</span> - r_out_perp.<span class="hljs-built_in">length_squared</span>())) * n;<br><span class="hljs-keyword">return</span> r_out_perp + r_out_parallel;<br>&#125;<br></code></pre></div></td></tr></table></figure><h6 id="照相机结构">9. 照相机结构</h6><p><img src="https://raw.githubusercontent.com/zcy510/imagebed/main/img/202204181617633.png" srcset="/img/loading.gif" lazyload alt="image-20211226203052922" style="zoom: 50%;" /></p><p><span class="math inline">\(fov\)</span> 为照相机视角，则半视高 <spanclass="math inline">\(h=\tan\dfrac{fov}{2}\)</span>，则视图高为 <spanclass="math inline">\(2*h\)</span>。 <spanclass="math inline">\(vup\)</span>为垂直于视图的的向量，用于确定照相机的位置。<spanclass="math inline">\(low\)</span><em><spanclass="math inline">\(left\)</span> </em> <spanclass="math inline">\(corner\)</span>用来辅助计算照相机射出的光线的方向。同时为了模拟真实照相机，因为真实照相机的传感器是有面积的，所以从照相机内射出的光线不都是从<span class="math inline">\(orgin\)</span>位置射出，故在获取光线的时候，在 <spanclass="math inline">\(origin\)</span> 的基础上加上了 <spanclass="math inline">\(origin\)</span> 位置的随机偏移量。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">camera</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">camera</span>(<br>            point3 lookfrom,<br>            point3 lookat,<br>            vec3   vup,<br>            <span class="hljs-type">double</span> vfov, <span class="hljs-comment">// vertical field-of-view in degrees</span><br>            <span class="hljs-type">double</span> aspect_ratio,<br>            <span class="hljs-type">double</span> aperture,<br>            <span class="hljs-type">double</span> focus_dist<br>    ) &#123;<br>        <span class="hljs-keyword">auto</span> theta = <span class="hljs-built_in">degrees_to_radians</span>(vfov);<br>        <span class="hljs-keyword">auto</span> h = <span class="hljs-built_in">tan</span>(theta/<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">auto</span> viewport_height = <span class="hljs-number">2.0</span> * h;<br>        <span class="hljs-keyword">auto</span> viewport_width = aspect_ratio * viewport_height;<br><br>        w = <span class="hljs-built_in">unit_vector</span>(lookfrom - lookat);<br>        u = <span class="hljs-built_in">unit_vector</span>(<span class="hljs-built_in">cross</span>(vup, w));<br>        v = <span class="hljs-built_in">cross</span>(w, u);<br><br>        origin = lookfrom;<br>        horizontal = focus_dist * viewport_width * u;<br>        vertical = focus_dist * viewport_height * v;<br>        lower_left_corner = origin - horizontal/<span class="hljs-number">2</span> - vertical/<span class="hljs-number">2</span> - focus_dist*w;<br><br>        lens_radius = aperture / <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-function">ray <span class="hljs-title">get_ray</span><span class="hljs-params">(<span class="hljs-type">double</span> s, <span class="hljs-type">double</span> t)</span> <span class="hljs-type">const</span> </span>&#123;<br>        vec3 rd = lens_radius * <span class="hljs-built_in">random_in_unit_disk</span>();<br>        vec3 offset = u * rd.<span class="hljs-built_in">x</span>() + v * rd.<span class="hljs-built_in">y</span>();<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ray</span>(<br>                origin + offset,<br>                lower_left_corner + s*horizontal + t*vertical - origin - offset<br>        );<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    point3 origin;<br>    point3 lower_left_corner;<br>    vec3 horizontal;<br>    vec3 vertical;<br>    vec3 u, v, w;<br>    <span class="hljs-type">double</span> lens_radius;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="第四章.-辅助工具包">第四章. 辅助工具包</h5><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">本项目在计算空间直线与椭球的交点时使用了一个高级的C++模板头库————Eigen。它提供了用于线性代数、矩阵和向量运算、几何变换、数值求解器和相关算法。<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
      <tag>Ray Tracing</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
